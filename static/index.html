<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPTV èŠ‚ç›®ç®¡ç†</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        body.dark-mode {
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        body.dark-mode .header {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .links {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .filter-section {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
        }

        .filter-btn:hover {
            background: #5a6268;
        }

        .filter-btn.active {
            background: #667eea;
        }

        .filter-btn.active:hover {
            background: #5a6fd8;
        }

        .link {
            padding: 12px 24px;
            background: #007bff;
            color: white;
            text-decoration: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            font-size: 14px;
        }

        .link:hover {
            background: #0056b3;
            transform: translateY(-1px);
        }

        .theme-toggle {
            background: none;
            border: 2px solid #ddd;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .theme-toggle:hover {
            background: #f8f9fa;
            border-color: #aaa;
        }

        .epg-indicator {
            font-size: 1.2rem;
            font-weight: bold;
            margin-left: 10px;
        }

        .epg-available {
            color: #4CAF50;
        }

        .epg-unavailable {
            color: #f44336;
        }

        body.dark-mode .theme-toggle {
            border-color: #4a5568;
            color: #cbd5e0;
        }

        body.dark-mode .theme-toggle:hover {
            background: #4a5568;
            border-color: #718096;
        }

        .copy-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
            font-weight: 500;
        }

        .copy-toast.show {
            transform: translateX(0);
        }

        .channels {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
        }

        .channel {
            background: white;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            cursor: pointer;
            border: 2px solid transparent;
        }

        body.dark-mode .channel {
            background: #2d3748;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .channel:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border-color: #667eea;
        }

        body.dark-mode .channel:hover {
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }

        .channel-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .channel-logo {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            object-fit: cover;
            background: #4a5568;
            border: 1px solid #718096;
            flex-shrink: 0;
        }

        .no-logo-indicator {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            background: #f44336;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .no-logo-indicator:hover {
            background: #d32f2f;
            transform: scale(1.1);
        }

        .channel h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.2rem;
            font-weight: 600;
        }

        body.dark-mode .channel h3 {
            color: #f7fafc;
        }

        .channel p {
            margin: 8px 0;
            line-height: 1.5;
            color: #666;
        }

        body.dark-mode .channel p {
            color: #cbd5e0;
        }

        .channel strong {
            color: #333;
            font-weight: 600;
        }

        body.dark-mode .channel strong {
            color: #f7fafc;
        }

        .loading {
            text-align: center;
            padding: 50px;
            color: #666;
            font-size: 1.1rem;
        }

        body.dark-mode .loading {
            color: #cbd5e0;
        }

        .error {
            text-align: center;
            padding: 50px;
            color: #e74c3c;
            font-size: 1.1rem;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .epg-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            backdrop-filter: blur(4px);
        }

        .epg-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            padding: 2rem;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            width: 90%;
            transition: background-color 0.3s ease;
        }

        body.dark-mode .epg-content {
            background: #2d3748;
        }

        .epg-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #f0f0f0;
        }

        body.dark-mode .epg-header {
            border-bottom-color: #4a5568;
        }

        .mapping-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            border-left: 4px solid #667eea;
        }

        body.dark-mode .mapping-section {
            background: #4a5568;
            border-left-color: #cbd5e0;
        }

        .mapping-label {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        body.dark-mode .mapping-label {
            color: #cbd5e0;
        }

        .mapping-select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
            font-size: 0.9rem;
        }

        body.dark-mode .mapping-select {
            background: #2d3748;
            border-color: #4a5568;
            color: #f7fafc;
        }

        .mapping-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
        }

        .epg-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
        }

        body.dark-mode .epg-title {
            color: #f7fafc;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: #f0f0f0;
            color: #333;
        }

        body.dark-mode .close-btn {
            color: #cbd5e0;
        }

        body.dark-mode .close-btn:hover {
            background: #4a5568;
            color: #f7fafc;
        }

        .epg-list {
            list-style: none;
        }

        .epg-item {
            padding: 1rem;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s ease;
        }

        body.dark-mode .epg-item {
            border-bottom-color: #4a5568;
        }

        .epg-item.current {
            background: #e8f5e8;
            border-left: 4px solid #4CAF50;
            color: #2e7d32;
        }

        body.dark-mode .epg-item.current {
            background: #1b5e20;
            border-left-color: #66bb6a;
            color: #c8e6c9;
        }

        .epg-item.past {
            opacity: 0.7;
        }

        .epg-item:hover {
            background: #f8f9fa;
        }

        body.dark-mode .epg-item:hover {
            background: #4a5568;
        }

        .epg-item:last-child {
            border-bottom: none;
        }

        .epg-time {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 0.5rem;
        }

        body.dark-mode .epg-time {
            color: #cbd5e0;
        }

        .epg-program-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 0.25rem;
        }

        body.dark-mode .epg-program-title {
            color: #f7fafc;
        }

        .epg-description {
            font-size: 0.9rem;
            color: #666;
            line-height: 1.4;
        }

        body.dark-mode .epg-description {
            color: #cbd5e0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .links {
                justify-content: center;
            }
            
            .channels {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>IPTV èŠ‚ç›®ç®¡ç†æœåŠ¡</h1>
            <p>ç”µä¿¡IPTVé¢‘é“ç®¡ç†å’ŒèŠ‚ç›®å•æŸ¥çœ‹</p>
        </div>
        
        <div class="controls">
            <div class="links">
                <button class="link" onclick="copyToClipboard('playlist')">ğŸ“‹ å¤åˆ¶ M3U é“¾æ¥</button>
                <button class="link" onclick="copyToClipboard('xmltv')">ğŸ“‹ å¤åˆ¶ EPG é“¾æ¥</button>
                <button class="link" onclick="fetchEpg()" id="fetch-epg-btn">ğŸ“¥ è·å–æ‰€æœ‰ EPG</button>
                <button class="link" onclick="regenerateXmltv()" id="regenerate-btn">ğŸ”„ é‡æ–°ç”Ÿæˆ EPG</button>
                <button class="link" onclick="clearLogoCache()" id="clear-logo-btn">ğŸ–¼ï¸ æ¸…ç©ºLogoç¼“å­˜</button>
                <button class="link" onclick="window.open('/static/stats.html', '_blank')">ğŸ“Š æ’­æ”¾ç»Ÿè®¡</button>
                <span id="epg-stats" style="margin-left: 20px; color: #666; font-size: 14px;">åŠ è½½ä¸­...</span>
            </div>
            
            <div class="filter-section">
                <span>æ¸…æ™°åº¦:</span>
                <button class="filter-btn active" onclick="filterByQuality('all')">å…¨éƒ¨</button>
                <button class="filter-btn" onclick="filterByQuality('è¶…æ¸…é¢‘é“')">è¶…æ¸…</button>
                <button class="filter-btn" onclick="filterByQuality('é«˜æ¸…é¢‘é“')">é«˜æ¸…</button>
                <button class="filter-btn" onclick="filterByQuality('æ™®é€šé¢‘é“')">æ™®é€š</button>
            </div>
            
            <div class="filter-section">
                <span>EPG:</span>
                <button class="filter-btn active" onclick="filterByEpg('all')" id="epg-all-btn">å…¨éƒ¨</button>
                <button class="filter-btn" onclick="filterByEpg('with-epg')" id="epg-with-btn">æœ‰èŠ‚ç›®å•</button>
                <button class="filter-btn" onclick="filterByEpg('without-epg')" id="epg-without-btn">æ— èŠ‚ç›®å•</button>
                <button class="filter-btn" onclick="filterByEpg('mapped')" id="epg-mapped-btn">å·²æ˜ å°„</button>
            </div>
            
            <button class="theme-toggle" onclick="toggleTheme()">
                <span id="theme-icon">ğŸŒ™</span>
                <span id="theme-text">æ·±è‰²æ¨¡å¼</span>
            </button>
        </div>
        
        <div id="channels" class="channels">
            <div class="loading">
                <div class="spinner"></div>
                æ­£åœ¨åŠ è½½é¢‘é“åˆ—è¡¨...
            </div>
        </div>
    </div>

    <div id="copy-toast" class="copy-toast">
        å·²å¤åˆ¶é“¾æ¥ï¼
    </div>

    <div id="epg-modal" class="epg-modal">
        <div class="epg-content">
            <div class="epg-header">
                <div class="epg-title" id="epg-channel-name">èŠ‚ç›®å•</div>
                <button class="close-btn" onclick="closeEpgModal()">&times;</button>
            </div>
            <div class="mapping-section">
                <div class="mapping-label">å¦‚æ— å°æ ‡å’ŒèŠ‚ç›®å•ï¼Œå¯é€‰æ‹©æ˜ å°„åˆ°å…¶ä»–é¢‘é“ï¼š</div>
                <select class="mapping-select" id="mapping-select" onchange="onMappingChange()">
                    <option value="">è¯·é€‰æ‹©æ˜ å°„é¢‘é“...</option>
                </select>
            </div>
            <div id="epg-list-container">
                <div class="loading">
                    <div class="spinner"></div>
                    æ­£åœ¨åŠ è½½èŠ‚ç›®å•...
                </div>
            </div>
        </div>
    </div>

    <script>
        let channels = [];
        let allChannels = []; // å­˜å‚¨æ‰€æœ‰é¢‘é“æ•°æ®ï¼Œç”¨äºæ˜ å°„æŸ¥æ‰¾
        let isDarkMode = false;
        let currentQualityFilter = 'all';
        let currentEpgFilter = 'all'; // EPGç­›é€‰ï¼šall, with-epg, without-epg
        let currentChannel = null;
        let channelMappings = new Map(); // å­˜å‚¨é¢‘é“æ˜ å°„å…³ç³»

        // åˆå§‹åŒ–ä¸»é¢˜
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                enableDarkMode();
            }
        }

        function toggleTheme() {
            if (isDarkMode) {
                disableDarkMode();
            } else {
                enableDarkMode();
            }
        }

        function enableDarkMode() {
            document.body.classList.add('dark-mode');
            document.getElementById('theme-icon').textContent = 'â˜€ï¸';
            document.getElementById('theme-text').textContent = 'æµ…è‰²æ¨¡å¼';
            localStorage.setItem('theme', 'dark');
            isDarkMode = true;
        }

        function disableDarkMode() {
            document.body.classList.remove('dark-mode');
            document.getElementById('theme-icon').textContent = 'ğŸŒ™';
            document.getElementById('theme-text').textContent = 'æ·±è‰²æ¨¡å¼';
            localStorage.setItem('theme', 'light');
            isDarkMode = false;
        }

        function filterByQuality(quality) {
            currentQualityFilter = quality;
            
            // æ›´æ–°è´¨é‡ç­›é€‰æŒ‰é’®çŠ¶æ€
            const qualityButtons = document.querySelectorAll('.filter-btn');
            qualityButtons.forEach(btn => {
                if (!btn.id.startsWith('epg-')) { // åªå¤„ç†è´¨é‡ç­›é€‰æŒ‰é’®
                    btn.classList.remove('active');
                }
            });
            
            // æ‰¾åˆ°å¯¹åº”çš„è´¨é‡æŒ‰é’®å¹¶è®¾ç½®ä¸ºactive
            qualityButtons.forEach(btn => {
                const btnText = btn.textContent;
                if (!btn.id.startsWith('epg-') && 
                    ((quality === 'all' && btnText === 'å…¨éƒ¨') ||
                    (quality === 'è¶…æ¸…é¢‘é“' && btnText === 'è¶…æ¸…') ||
                    (quality === 'é«˜æ¸…é¢‘é“' && btnText === 'é«˜æ¸…') ||
                    (quality === 'æ™®é€šé¢‘é“' && btnText === 'æ™®é€š'))) {
                    btn.classList.add('active');
                }
            });
            
            renderChannels(getFilteredChannels());
        }

        function filterByEpg(epgFilter) {
            currentEpgFilter = epgFilter;
            
            // æ›´æ–°EPGç­›é€‰æŒ‰é’®çŠ¶æ€
            const epgButtons = ['epg-all-btn', 'epg-with-btn', 'epg-without-btn', 'epg-mapped-btn'];
            epgButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.classList.remove('active');
                }
            });
            
            // è®¾ç½®å¯¹åº”çš„EPGæŒ‰é’®ä¸ºactive
            let activeBtnId;
            switch(epgFilter) {
                case 'all':
                    activeBtnId = 'epg-all-btn';
                    break;
                case 'with-epg':
                    activeBtnId = 'epg-with-btn';
                    break;
                case 'without-epg':
                    activeBtnId = 'epg-without-btn';
                    break;
                case 'mapped':
                    activeBtnId = 'epg-mapped-btn';
                    break;
            }
            if (activeBtnId) {
                const activeBtn = document.getElementById(activeBtnId);
                if (activeBtn) {
                    activeBtn.classList.add('active');
                }
            }
            
            renderChannels(getFilteredChannels());
        }

        function getFilteredChannels() {
            let filteredChannels = channels;
            
            // å…ˆæŒ‰è´¨é‡ç­›é€‰
            if (currentQualityFilter !== 'all') {
                filteredChannels = filteredChannels.filter(channel => channel.category === currentQualityFilter);
            }
            
            // å†æŒ‰EPGç­›é€‰
            if (currentEpgFilter !== 'all') {
                filteredChannels = filteredChannels.filter(channel => {
                    if (currentEpgFilter === 'mapped') {
                        // ç­›é€‰å·²æ˜ å°„çš„é¢‘é“
                        return channelMappings.has(channel.id);
                    } else {
                        const hasEpg = hasChannelEpg(channel);
                        if (currentEpgFilter === 'with-epg') {
                            return hasEpg;
                        } else if (currentEpgFilter === 'without-epg') {
                            return !hasEpg;
                        }
                    }
                    return true;
                });
            }
            
            return filteredChannels;
        }

        // æ£€æŸ¥é¢‘é“æ˜¯å¦æœ‰EPGæ•°æ®ï¼ˆåŒ…æ‹¬æ˜ å°„ï¼‰
        function hasChannelEpg(channel) {
            // æ£€æŸ¥é¢‘é“è‡ªèº«æ˜¯å¦æœ‰EPG
            if (channel.epg && channel.epg.length > 0) {
                return true;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ˜ å°„ï¼Œä¸”æ˜ å°„çš„æºé¢‘é“æœ‰EPG
            const mappedChannelId = channelMappings.get(channel.id);
            if (mappedChannelId) {
                const mappedChannel = allChannels.find(ch => ch.id === mappedChannelId);
                if (mappedChannel && mappedChannel.epg && mappedChannel.epg.length > 0) {
                    return true;
                }
            }
            
            return false;
        }

        function loadMappingsFromStorage() {
            try {
                const stored = localStorage.getItem('channelMappings');
                if (stored) {
                    const mappings = JSON.parse(stored);
                    channelMappings = new Map(mappings);
                    
                    // åŒæ­¥åˆ°åç«¯
                    syncMappingsToBackend();
                }
            } catch (error) {
                console.error('åŠ è½½æ˜ å°„é…ç½®å¤±è´¥:', error);
            }
        }

        function saveMappingsToStorage() {
            try {
                localStorage.setItem('channelMappings', JSON.stringify(Array.from(channelMappings.entries())));
                
                // åŒæ­¥åˆ°åç«¯
                syncMappingsToBackend();
            } catch (error) {
                console.error('ä¿å­˜æ˜ å°„é…ç½®å¤±è´¥:', error);
            }
        }

        async function syncMappingsToBackend() {
            try {
                const mappingsArray = Array.from(channelMappings.entries()).map(([from_id, to_id]) => ({
                    from_id: parseInt(from_id),
                    to_id: parseInt(to_id)
                }));
                
                const response = await fetch('/api/channel-mappings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ mappings: mappingsArray })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                console.log('æ˜ å°„é…ç½®å·²åŒæ­¥åˆ°åç«¯');
            } catch (error) {
                console.error('åŒæ­¥æ˜ å°„é…ç½®åˆ°åç«¯å¤±è´¥:', error);
            }
        }

        function onMappingChange() {
            const mappingSelect = document.getElementById('mapping-select');
            const selectedChannelId = mappingSelect.value;
            
            if (!currentChannel) return;
            
            if (selectedChannelId) {
                // è®¾ç½®æ˜ å°„
                channelMappings.set(currentChannel.id, parseInt(selectedChannelId));
                console.log(`è®¾ç½®æ˜ å°„: ${currentChannel.name} (${currentChannel.id}) -> ${selectedChannelId}`);
                
                // é‡æ–°åŠ è½½EPGæ•°æ®
                loadChannelEpg(currentChannel.id);
            } else {
                // åˆ é™¤æ˜ å°„
                channelMappings.delete(currentChannel.id);
                console.log(`åˆ é™¤æ˜ å°„: ${currentChannel.name} (${currentChannel.id})`);
                
                // é‡æ–°åŠ è½½EPGæ•°æ®
                loadChannelEpg(currentChannel.id);
            }
            
            // ä¿å­˜æ˜ å°„åˆ°localStorage
            saveMappingsToStorage();
            
            // é‡æ–°æ¸²æŸ“é¢‘é“åˆ—è¡¨ä»¥æ›´æ–°å°æ ‡æ˜¾ç¤º
            renderChannels(getFilteredChannels());
        }

        async function loadChannelEpg(channelId) {
            const listContainer = document.getElementById('epg-list-container');
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æ˜ å°„
            const mappedChannelId = channelMappings.get(channelId) || channelId;
            
            listContainer.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    æ­£åœ¨åŠ è½½èŠ‚ç›®å•...
                </div>
            `;
            
            // ç›´æ¥ä»APIè·å–EPGæ•°æ®
            try {
                console.log(`Fetching EPG data for channel ${mappedChannelId}`);
                const response = await fetch(`/api/channel/${mappedChannelId}/epg`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const epgData = await response.json();
                console.log(`Got ${epgData.length} programs for channel ${mappedChannelId}`);
                renderEpg(epgData);
            } catch (error) {
                console.error('EPG fetch error:', error);
                listContainer.innerHTML = `
                    <div class="error">
                        åŠ è½½èŠ‚ç›®å•å¤±è´¥: ${error.message}<br>
                        <small>è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•</small>
                    </div>
                `;
            }
        }

        async function fetchEpg() {
            const btn = document.getElementById('fetch-epg-btn');
            const originalText = btn.textContent;
            btn.textContent = 'ğŸ“¥ è·å–ä¸­...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/fetch-epg', {
                    method: 'POST',
                });
                
                if (response.ok) {
                    const result = await response.text();
                    showToast(result);
                    
                    // è·å–æˆåŠŸåé‡æ–°åŠ è½½é¢‘é“åˆ—è¡¨ä»¥æ›´æ–°EPGçŠ¶æ€
                    setTimeout(async () => {
                        await loadChannels();
                        // ç„¶åé‡æ–°ç”ŸæˆXMLTV
                        regenerateXmltv();
                    }, 1000);
                } else {
                    const error = await response.text();
                    showToast(`è·å–å¤±è´¥: ${error}`);
                }
            } catch (error) {
                showToast(`ç½‘ç»œé”™è¯¯: ${error.message}`);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        async function clearLogoCache() {
            const btn = document.getElementById('clear-logo-btn');
            const originalText = btn.textContent;
            btn.textContent = 'ğŸ–¼ï¸ æ¸…ç©ºä¸­...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/clear-logo-cache', {
                    method: 'POST',
                });
                
                if (response.ok) {
                    const result = await response.text();
                    showToast(result + 'ï¼Œé¡µé¢å°†åˆ·æ–°ä»¥åŠ è½½æ–°Logo');
                    
                    // æ¸…ç©ºååˆ·æ–°é¡µé¢ä»¥é‡æ–°åŠ è½½Logo
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);
                } else {
                    const error = await response.text();
                    showToast(`æ¸…ç©ºå¤±è´¥: ${error}`);
                }
            } catch (error) {
                showToast(`ç½‘ç»œé”™è¯¯: ${error.message}`);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        async function regenerateXmltv() {
            const btn = document.getElementById('regenerate-btn');
            const originalText = btn.textContent;
            btn.textContent = 'ğŸ”„ ç”Ÿæˆä¸­...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/regenerate-xmltv', {
                    method: 'POST',
                });
                
                if (response.ok) {
                    showToast('EPG é‡æ–°ç”ŸæˆæˆåŠŸï¼');
                } else {
                    const error = await response.text();
                    showToast(`ç”Ÿæˆå¤±è´¥: ${error}`);
                }
            } catch (error) {
                showToast(`ç½‘ç»œé”™è¯¯: ${error.message}`);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        async function checkCacheStatus() {
            const btn = document.getElementById('cache-status-btn');
            const originalText = btn.textContent;
            btn.textContent = 'ğŸ” æ£€æŸ¥ä¸­...';
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/cache-status');
                const status = await response.text();
                
                // å»æ‰å¼•å·
                const cleanStatus = status.replace(/"/g, '');
                
                let message = '';
                switch(cleanStatus) {
                    case 'cached_in_memory_and_file':
                        message = 'âœ… ç¼“å­˜çŠ¶æ€ï¼šå†…å­˜å’Œæ–‡ä»¶éƒ½æœ‰ç¼“å­˜';
                        break;
                    case 'cached_in_memory_only':
                        message = 'âš ï¸ ç¼“å­˜çŠ¶æ€ï¼šä»…å†…å­˜æœ‰ç¼“å­˜';
                        break;
                    case 'cached_in_file_only':
                        message = 'âš ï¸ ç¼“å­˜çŠ¶æ€ï¼šä»…æ–‡ä»¶æœ‰ç¼“å­˜';
                        break;
                    case 'not_cached':
                        message = 'âŒ ç¼“å­˜çŠ¶æ€ï¼šæ— ç¼“å­˜';
                        break;
                    case 'cache_lock_error':
                        message = 'âŒ ç¼“å­˜çŠ¶æ€ï¼šç¼“å­˜é”å®šé”™è¯¯';
                        break;
                    default:
                        message = `â“ ç¼“å­˜çŠ¶æ€ï¼š${cleanStatus}`;
                }
                
                showToast(message);
            } catch (error) {
                showToast(`ç½‘ç»œé”™è¯¯: ${error.message}`);
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'copy-toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.classList.add('show');
            }, 100);
            
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300);
            }, 3000);
        }

        async function copyToClipboard(type) {
            const baseUrl = window.location.origin;
            const url = type === 'playlist' ? `${baseUrl}/playlist` : `${baseUrl}/xmltv`;
            
            try {
                await navigator.clipboard.writeText(url);
                showCopyToast();
            } catch (err) {
                // é™çº§æ–¹æ¡ˆ
                const textArea = document.createElement('textarea');
                textArea.value = url;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showCopyToast();
            }
        }

        function showCopyToast() {
            const toast = document.getElementById('copy-toast');
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // æ›´æ–°EPGç»Ÿè®¡ä¿¡æ¯
        function updateEpgStats() {
            // è®¡ç®—æœ‰EPGçš„é¢‘é“æ•°ï¼ŒåŒ…æ‹¬æ˜ å°„çš„æƒ…å†µ
            const withEpg = channels.filter(channel => {
                // æ£€æŸ¥é¢‘é“è‡ªèº«æ˜¯å¦æœ‰EPG
                if (channel.epg && channel.epg.length > 0) {
                    return true;
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰æ˜ å°„ï¼Œä¸”æ˜ å°„çš„æºé¢‘é“æœ‰EPG
                const mappedChannelId = channelMappings.get(channel.id);
                if (mappedChannelId) {
                    const mappedChannel = allChannels.find(ch => ch.id === mappedChannelId);
                    if (mappedChannel && mappedChannel.epg && mappedChannel.epg.length > 0) {
                        return true;
                    }
                }
                
                return false;
            }).length;
            
            const withoutEpg = channels.length - withEpg;
            const statsElement = document.getElementById('epg-stats');
            if (statsElement) {
                statsElement.innerHTML = `EPG: ${withEpg}/${channels.length} (æœ‰${withEpg}ä¸ªé¢‘é“, æ— ${withoutEpg}ä¸ª)`;
            }
        }

        async function loadChannels() {
            try {
                // å°è¯•è·å–å¸¦EPGçš„é¢‘é“åˆ—è¡¨
                const response = await fetch('/api/channels-with-epg');
                if (!response.ok) {
                    // å¦‚æœå¤±è´¥ï¼Œå›é€€åˆ°æ™®é€šé¢‘é“åˆ—è¡¨
                    console.log('è·å–å¸¦EPGçš„é¢‘é“å¤±è´¥ï¼Œå›é€€åˆ°æ™®é€šåˆ—è¡¨');
                    const fallbackResponse = await fetch('/api/channels');
                    if (!fallbackResponse.ok) {
                        throw new Error('è·å–é¢‘é“åˆ—è¡¨å¤±è´¥');
                    }
                    channels = await fallbackResponse.json();
                } else {
                    channels = await response.json();
                }
                
                // æ›´æ–° allChannels ç”¨äºæ˜ å°„æŸ¥æ‰¾
                allChannels = [...channels];
                
                console.log(`åŠ è½½äº† ${channels.length} ä¸ªé¢‘é“`);
                if (channels.length > 0) {
                    console.log('ç¬¬ä¸€ä¸ªé¢‘é“ç¤ºä¾‹:', channels[0]);
                    // ç»Ÿè®¡åˆ†ç±»åˆ†å¸ƒ
                    const categoryCount = {};
                    channels.forEach(ch => {
                        const cat = ch.category || 'æœªåˆ†ç±»';
                        categoryCount[cat] = (categoryCount[cat] || 0) + 1;
                    });
                    console.log('åˆ†ç±»ç»Ÿè®¡:', categoryCount);
                }
                
                // åŠ è½½æ˜ å°„é…ç½®
                loadMappingsFromStorage();
                
                // æ›´æ–°EPGç»Ÿè®¡
                updateEpgStats();
                
                renderChannels(getFilteredChannels());
            } catch (error) {
                console.error('åŠ è½½é¢‘é“å¤±è´¥:', error);
                document.getElementById('channels').innerHTML = `
                    <div class="error">åŠ è½½å¤±è´¥: ${error.message}</div>
                `;
            }
        }

        // è·å–EPGæŒ‡ç¤ºå™¨æ ·å¼ç±»
        function getEpgIndicatorClass(channel) {
            // æ£€æŸ¥æ˜¯å¦æœ‰æ˜ å°„
            const mappedChannelId = channelMappings.get(channel.id);
            if (mappedChannelId) {
                // å¦‚æœæœ‰æ˜ å°„ï¼ŒæŸ¥æ‰¾æ˜ å°„çš„é¢‘é“
                const mappedChannel = allChannels.find(ch => ch.id === mappedChannelId);
                if (mappedChannel && mappedChannel.epg && mappedChannel.epg.length > 0) {
                    return 'epg-available';
                }
            }
            // å¦‚æœæ²¡æœ‰æ˜ å°„æˆ–æ˜ å°„çš„é¢‘é“æ²¡æœ‰EPGï¼Œä½¿ç”¨è‡ªå·±çš„EPGçŠ¶æ€
            return (channel.epg && channel.epg.length > 0) ? 'epg-available' : 'epg-unavailable';
        }

        // è·å–EPGæŒ‡ç¤ºå™¨æ ‡é¢˜
        function getEpgIndicatorTitle(channel) {
            // æ£€æŸ¥æ˜¯å¦æœ‰æ˜ å°„
            const mappedChannelId = channelMappings.get(channel.id);
            if (mappedChannelId) {
                // å¦‚æœæœ‰æ˜ å°„ï¼ŒæŸ¥æ‰¾æ˜ å°„çš„é¢‘é“
                const mappedChannel = allChannels.find(ch => ch.id === mappedChannelId);
                if (mappedChannel && mappedChannel.epg && mappedChannel.epg.length > 0) {
                    const mappedChannelName = allChannels.find(ch => ch.id === mappedChannelId)?.name || mappedChannelId;
                    return `é€šè¿‡æ˜ å°„ä» ${mappedChannelName} è·å–äº† ${mappedChannel.epg.length} ä¸ªèŠ‚ç›®`;
                }
            }
            // å¦‚æœæ²¡æœ‰æ˜ å°„æˆ–æ˜ å°„çš„é¢‘é“æ²¡æœ‰EPGï¼Œä½¿ç”¨è‡ªå·±çš„EPGçŠ¶æ€
            if (channel.epg && channel.epg.length > 0) {
                return `æœ‰ ${channel.epg.length} ä¸ªèŠ‚ç›®`;
            }
            return 'æ— EPGæ•°æ®';
        }

        // è·å–EPGæŒ‡ç¤ºå™¨ç¬¦å·
        function getEpgIndicatorSymbol(channel) {
            // æ£€æŸ¥æ˜¯å¦æœ‰æ˜ å°„
            const mappedChannelId = channelMappings.get(channel.id);
            if (mappedChannelId) {
                // å¦‚æœæœ‰æ˜ å°„ï¼ŒæŸ¥æ‰¾æ˜ å°„çš„é¢‘é“
                const mappedChannel = allChannels.find(ch => ch.id === mappedChannelId);
                if (mappedChannel && mappedChannel.epg && mappedChannel.epg.length > 0) {
                    return 'â—'; // å®å¿ƒåœ†è¡¨ç¤ºæœ‰EPG
                }
            }
            // å¦‚æœæ²¡æœ‰æ˜ å°„æˆ–æ˜ å°„çš„é¢‘é“æ²¡æœ‰EPGï¼Œä½¿ç”¨è‡ªå·±çš„EPGçŠ¶æ€
            return (channel.epg && channel.epg.length > 0) ? 'â—' : 'â—‹';
        }

        function renderChannels(channelsToRender) {
            const container = document.getElementById('channels');
            if (channelsToRender.length === 0) {
                container.innerHTML = '<div class="error">æ²¡æœ‰æ‰¾åˆ°é¢‘é“</div>';
                return;
            }

            container.innerHTML = channelsToRender.map(channel => {
                // æ£€æŸ¥æ˜¯å¦æœ‰æ˜ å°„ï¼Œä½¿ç”¨æ˜ å°„åçš„IDè·å–å°æ ‡
                const mappedChannelId = channelMappings.get(channel.id) || channel.id;
                const logoUrl = `/logo/${mappedChannelId}.png`;
                const category = channel.category || 'æ™®é€šé¢‘é“'; // fallback for undefined
                const rtspShort = channel.rtsp.length > 40 ? channel.rtsp.substring(0, 40) + '...' : channel.rtsp;
                
                console.log(`é¢‘é“: ${channel.name}, åˆ†ç±»: ${channel.category}`); // è°ƒè¯•ç”¨
                
                return `
                    <div class="channel" onclick="showChannelDetails(${channel.id})">
                        <div class="channel-header">
                            <img src="${logoUrl}" alt="${channel.name}" class="channel-logo" 
                                 data-channel-id="${channel.id}"
                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" 
                                 onload="this.style.display='block'; this.nextElementSibling.style.display='none';">
                            <div class="no-logo-indicator" style="display: none;" onclick="event.stopPropagation(); showChannelMapping(${channel.id})">!</div>
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; justify-content: space-between;">
                                    <h3 style="margin: 0;">${channel.name}</h3>
                                    <span class="epg-indicator ${getEpgIndicatorClass(channel)}" 
                                          title="${getEpgIndicatorTitle(channel)}">
                                        ${getEpgIndicatorSymbol(channel)}
                                    </span>
                                </div>
                                <p><strong>åˆ†ç±»:</strong> ${category}</p>
                            </div>
                        </div>
                        <p><strong>é¢‘é“ID:</strong> ${channel.id}</p>
                        <p style="word-break: break-all; font-size: 0.8rem; line-height: 1.3;"><strong>RTSP:</strong> ${rtspShort}</p>
                        ${channel.igmp ? `<p style="word-break: break-all; font-size: 0.8rem; line-height: 1.3;"><strong>IGMP:</strong> ${channel.igmp}</p>` : ''}
                    </div>
                `;
            }).join('');
        }

        function showChannelMapping(channelId) {
            // ç›´æ¥æ‰“å¼€EPGå¼¹çª—è¿›è¡Œæ˜ å°„
            showChannelDetails(channelId);
        }

        async function showChannelDetails(channelId) {
            const channel = channels.find(c => c.id === channelId);
            if (!channel) return;

            currentChannel = channel;
            const modal = document.getElementById('epg-modal');
            const channelName = document.getElementById('epg-channel-name');
            const listContainer = document.getElementById('epg-list-container');
            const mappingSelect = document.getElementById('mapping-select');
            
            channelName.textContent = `${channel.name} - èŠ‚ç›®å•`;
            
            // å¡«å……æ˜ å°„é€‰æ‹©æ¡†
            mappingSelect.innerHTML = '<option value="">è¯·é€‰æ‹©æ˜ å°„é¢‘é“...</option>';
            channels
                .filter(ch => ch.id !== channel.id)
                .sort((a, b) => a.name.localeCompare(b.name, 'zh-CN'))
                .forEach(ch => {
                    const option = document.createElement('option');
                    option.value = ch.id;
                    
                    // æ£€æŸ¥é¢‘é“æ˜¯å¦æœ‰åŸå§‹EPGæ•°æ®
                    const hasOriginalEpg = ch.epg && ch.epg.length > 0;
                    const epgIndicator = hasOriginalEpg ? ' â—' : ' â—‹'; // â— è¡¨ç¤ºæœ‰EPGï¼Œâ—‹ è¡¨ç¤ºæ— EPG
                    
                    option.textContent = `${ch.name}${epgIndicator}`;
                    if (hasOriginalEpg) {
                        option.title = `${ch.name} - æœ‰ ${ch.epg.length} ä¸ªåŸå§‹èŠ‚ç›®`;
                    } else {
                        option.title = `${ch.name} - æ— åŸå§‹èŠ‚ç›®å•`;
                    }
                    
                    mappingSelect.appendChild(option);
                });
            
            // è®¾ç½®å½“å‰æ˜ å°„é€‰æ‹©
            const currentMapping = channelMappings.get(channel.id);
            if (currentMapping) {
                mappingSelect.value = currentMapping;
            }
            
            modal.style.display = 'block';
            
            // åŠ è½½EPGæ•°æ®
            await loadChannelEpg(channel.id);
        }

        function renderEpg(epgData) {
            const container = document.getElementById('epg-list-container');
            
            if (!epgData || epgData.length === 0) {
                container.innerHTML = '<div class="error">æš‚æ— èŠ‚ç›®å•æ•°æ®</div>';
                return;
            }
            
            // æŒ‰æ—¶é—´æ’åº
            epgData.sort((a, b) => a.start - b.start);
            
            const list = document.createElement('ul');
            list.className = 'epg-list';
            
            const now = Date.now();
            let currentProgramElement = null;
            
            epgData.forEach((program, index) => {
                const item = document.createElement('li');
                const startTime = new Date(program.start);
                const endTime = new Date(program.stop);
                
                // åˆ¤æ–­èŠ‚ç›®çŠ¶æ€
                if (program.start <= now && program.stop > now) {
                    item.className = 'epg-item current';
                    currentProgramElement = item;
                } else if (program.stop <= now) {
                    item.className = 'epg-item past';
                } else {
                    item.className = 'epg-item future';
                }
                
                const timeStr = `${formatTime(startTime)} - ${formatTime(endTime)}`;
                const dateStr = formatDate(startTime);
                
                item.innerHTML = `
                    <div class="epg-time">${dateStr} ${timeStr}</div>
                    <div class="epg-program-title">${program.title}</div>
                    ${program.desc && program.desc !== program.title ? 
                        `<div class="epg-description">${program.desc}</div>` : ''}
                `;
                
                list.appendChild(item);
            });
            
            container.innerHTML = '';
            container.appendChild(list);
            
            // æ»šåŠ¨åˆ°å½“å‰èŠ‚ç›®
            if (currentProgramElement) {
                setTimeout(() => {
                    currentProgramElement.scrollIntoView({ 
                        behavior: 'smooth', 
                        block: 'center' 
                    });
                }, 100);
            }
        }

        function formatTime(date) {
            return date.toLocaleTimeString('zh-CN', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
        }

        function formatDate(date) {
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);
            
            if (date.toDateString() === today.toDateString()) {
                return 'ä»Šå¤©';
            } else if (date.toDateString() === yesterday.toDateString()) {
                return 'æ˜¨å¤©';
            } else if (date.toDateString() === tomorrow.toDateString()) {
                return 'æ˜å¤©';
            } else {
                return date.toLocaleDateString('zh-CN', { 
                    month: 'short', 
                    day: 'numeric' 
                });
            }
        }

        function closeEpgModal() {
            document.getElementById('epg-modal').style.display = 'none';
        }

        // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
        document.getElementById('epg-modal').onclick = function(e) {
            if (e.target === this) {
                closeEpgModal();
            }
        };

        // ESCé”®å…³é—­æ¨¡æ€æ¡†
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeEpgModal();
            }
        });

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initTheme();
            loadChannels();
        });
    </script>
</body>
</html>